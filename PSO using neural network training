import numpy as np
import matplotlib.pyplot as plt

def generate_data(n_samples=100):
    X = np.linspace(-1, 1, n_samples).reshape(-1, 1)
    y = np.sin(np.pi * X)
    return X, y


class SimpleNN:
    def __init__(self, input_size, hidden_size, output_size):
        self.input_size = input_size
        self.hidden_size = hidden_size
        self.output_size = output_size
        self.num_weights = input_size * hidden_size + hidden_size + hidden_size * output_size + output_size

    def set_weights(self, weights):
        idx = 0
        self.W1 = weights[idx:idx + self.input_size * self.hidden_size].reshape(self.input_size, self.hidden_size)
        idx += self.input_size * self.hidden_size
        self.b1 = weights[idx:idx + self.hidden_size]
        idx += self.hidden_size
        self.W2 = weights[idx:idx + self.hidden_size * self.output_size].reshape(self.hidden_size, self.output_size)
        idx += self.hidden_size * self.output_size
        self.b2 = weights[idx:idx + self.output_size]

    def forward(self, X):
        z1 = np.dot(X, self.W1) + self.b1
        a1 = np.tanh(z1)
        z2 = np.dot(a1, self.W2) + self.b2
        return z2

    def predict(self, X):
        return self.forward(X)


def loss_fn(y_true, y_pred):
    return np.mean((y_true - y_pred) ** 2)


class PSO:
    def __init__(self, nn, X, y, n_particles=30, max_iter=100, w=0.5, c1=1.5, c2=1.5):
        self.nn = nn
        self.X = X
        self.y = y
        self.n_particles = n_particles
        self.max_iter = max_iter
        self.dim = nn.num_weights
        self.w = w
        self.c1 = c1
        self.c2 = c2

        self.pos = np.random.randn(n_particles, self.dim)
        self.vel = np.zeros((n_particles, self.dim))
        self.pbest = self.pos.copy()
        self.pbest_scores = np.array([np.inf] * n_particles)
        self.gbest = None
        self.gbest_score = np.inf

    def evaluate(self, position):
        self.nn.set_weights(position)
        preds = self.nn.predict(self.X)
        return loss_fn(self.y, preds)

    def optimize(self):
        for iter in range(self.max_iter):
            for i in range(self.n_particles):
                fitness = self.evaluate(self.pos[i])
                if fitness < self.pbest_scores[i]:
                    self.pbest_scores[i] = fitness
                    self.pbest[i] = self.pos[i].copy()
                if fitness < self.gbest_score:
                    self.gbest_score = fitness
                    self.gbest = self.pos[i].copy()


            r1 = np.random.rand(self.n_particles, self.dim)
            r2 = np.random.rand(self.n_particles, self.dim)

            self.vel = self.w * self.vel + \
                       self.c1 * r1 * (self.pbest - self.pos) + \
                       self.c2 * r2 * (self.gbest - self.pos)
            self.pos += self.vel

            print(f"Iter {iter+1}/{self.max_iter}, Best Loss: {self.gbest_score:.6f}")

        return self.gbest

X_train, y_train = generate_data(100)

input_size = 1
hidden_size = 10
output_size = 1
nn = SimpleNN(input_size, hidden_size, output_size)


pso = PSO(nn, X_train, y_train, n_particles=30, max_iter=100)
best_weights = pso.optimize()


nn.set_weights(best_weights)
preds = nn.predict(X_train)

plt.plot(X_train, y_train, label='True Function')
plt.plot(X_train, preds, label='NN Prediction', linestyle='--')
plt.legend()
plt.title("PSO-Trained Neural Network")
plt.show()
